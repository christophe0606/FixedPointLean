# Examples

We have seen that mathematics can be built on another foundation: a programming language! But it is not your typical programming language. It is a language where the frontier between values, types, proofs, programs are becoming fuzzy.
It is a language with powerful concepts like inductive types and dependent types.

You can use this language like any other one and write programs. But you can benefit from all of its powerful features to better specify or constrain the behavior of your programs.

In short: you can write executable specifications that you can use to validate and test your other implementations, written for instance in `C`.

You can go further with libraries developed within the ecosystem. For instance, in the Lean 4 ecosystem, Amazon has developed a [library](https://github.com/leanprover/LNSym) that models parts of the Arm v8 instruction set. You could use such a library to validate code sequences which can be very useful in applications such as cryptography.

As part of this quick tutorial, I have written a [small library](https://github.com/christophe0606/FixedPointLean) to illustrate some ideas in the context to fixed-point arithmetic.

This book is part of the github repository for this library.

Let's review some extracts from the library.

## Fixed point datatype

Our fixed-point number datatype is built with the Lean 4 datatype `BitVec w` which is a bit vector of width `w`.

A fixed-point number can be signed or unsigned. For a given bit width, it can have different sizes for the fractional part. 

We want to encode all of this in the datatype.

First, let's define the `Sign` datatype:

```lean hljs
/-- Fixed point numbers can be signed or unsigned -/
inductive Sign where
| isSigned
| isUnsigned
deriving Repr
```

Let's define a utility function to determine how many bits are required to encode the sign:

```lean hljs
def signStorage (s : Sign) : Nat :=
  match s with
  | .isSigned => 1
  | .isUnsigned => 0
```

We need enough bits in the `BitVec` to encode the sign bit and the fractional part. The remaining bits (if any) are used for the integer part.

Let's define a property to check this:

```lean hljs
def hasEnoughStorage (s : Sign) (storage : Nat) (fractional : Nat) : Prop :=
  signStorage s + fractional ≤ storage
```

As you can see, the output of `hasEnoughStorage` lives in `Prop`. It means that for different values of the arguments of this function, we get different propositions.

Now, we can define our fixed-point datatype:

```lean hljs
structure Q (s : Sign) (storage : Nat) (fractional : Nat) where
  val : BitVec storage
  enough_storage : hasEnoughStorage s storage fractional := by decide
  fractional_not_zero : 0 < fractional  := by decide
  deriving BEq,Ord
```

The structure contains three fields:
* The `BitVec` containing the value
* A proof that enough bits are available to store the sign and fractional part
* A proof that the fractional part has at least one bit !

We define default proofs for the last two fields. Those default proofs are generated by the `decide` tactic.

It means that, in practice, proofs need to be provided only when the default proof created by the `decide` tactic cannot be used. 

As we explained, proofs have no computational content. So they are erased during the compilation. The final structure (generated by LLVM) only contains the field `val` for the bit vector.

Let's define an abbreviation for the usual `Q7` fixed-point format and start using it:

```lean hljs
abbrev sq7 := Q .isSigned 8 7
```

As you can see, the datatype contains information that is not saved as values of the structure. The sign (`.isSigned`), the datawidth (`8`) and the number of bits for the fractional part (`7`) are part of the type. They are not values inside the structure.

Now, let's use the `sq7` datatype:

```lean hljs
#eval (0xFF#8 : sq7)
```

The info view displays `-1`. No proof needs to be given. The bit vector was given using the Lean 4 syntax: `0xFF#8` for a `BitVec 8`.

## Fixed-point multiplication

Specifying the multiplication is an interesting exercise since the output format is not the same as the input.

In Lean 4, we implement an instance of the `HMul` type class to override the `*` operator.

But, I'll present things as if I was only implementing a `mul` function.

The type could be:
```lean hljs
def mul (x:Q s storage1 fractional1)
        (y:Q s storage2 fractional2) :
        (Q s (storage1 + storage2) (fractional1 + fractional2)) := ...

```

The `mul` function takes two arguments `x` and `y`. The output type is computed from the type of `x` and `y`.

We see that the output fixed-point has a bigger bit width, and more bits for the fractional part.

We also see that `x` and `y` must both be signed or unsigned since they use the same type variable `s` in their type.

To implement the function, we will need to provide the proofs that are required to build the result.

We have some properties available inside `x` and `y` that we can use to prove what is needed to build the output.

Here is the code. It is explained line per line just after:

```lean hljs
 :=
    let nw := storage1 + storage2
    match s with
    | .isSigned => .mk (x.val.signExtend nw * y.val.signExtend nw)
      (by
          have := x.enough_storage
          have := y.enough_storage
          omega
      )
      ( by have := x.fractional_not_zero
           have := y.fractional_not_zero
           omega
      )
    | .isUnsigned => .mk (x.val.zeroExtend nw * y.val.zeroExtend nw)
       (by
          have := x.enough_storage
          have := y.enough_storage
          omega
      )
      ( by have := x.fractional_not_zero
           have := y.fractional_not_zero
           omega
      )
```

Let's explain it line per line:

```lean hljs
 :=
    let nw := storage1 + storage2
```

`nw` is the amount of bits needed for the output bit vector.

Then, we pattern match on the sign and have two cases to consider. I'll only explain the signed case.

```lean hljs
| .isSigned => .mk
```

`.mk` is the constructor for the output `Q` structure. It is a short way to write it without having to use the full datatype as prefix. Otherwise we would need to write `(Q s (storage1 + storage2) (fractional1 + fractional2)).mk`.

We have seen in the definition of `Q` that there are three fields in this structure : the bit vector and two proofs for two properties. To create an output value, we need to provide the three expected arguments to `.mk`.

The value is easy and given by `x.val.signExtend nw * y.val.signExtend nw`

The fixed-point numbers are interpreted as signed (hence the `.signExtend`) and they are multiplied as bit vectors.

The second argument to `.mk` must be a proof of the property: `signStorage s + (fractional1 + fractional2) ≤ storage1 + storage2`. It is the `enough_storage` property for the output type.

The proof is:

```lean hljs
by
    have := x.enough_storage
    have := y.enough_storage
    omega
```

With the `have` tactic, we introduce what we know. The properties `enough_storage` from `x` and `y` that we need to prove the result. We know those properties are true otherwise we could not have created the values `x` and `y`.

`omega` is a powerful tactic than can solve integer and linear arithmetic problems. Here our problems it to prove an inequality. And `omega` just works. It is able to use the available assumptions to prove the result we need.

Writing proofs is interactive, you need to look at the info view. If you put the cursor just after `by`, the info view displays the goal remaining to be proved and the known assumptions at this point:

![Goal to be proved and known assumptions](pic2.png)

If you put the cursor after the `have`, you'll see two new assumptions named `this` with the `enough_storage` properties extracted from `x` and `y`

![Additional enough_storage assumptions](pic3.png)

And if you put the cursor after `omega`:

![No remaing goal to prove](pic4.png)

No remaining goal to prove ! `omega` was able to prove the goal.

You now have proved that the multiplication you have implemented is not breaking the properties of the `Q` datatype. If it was, you could not have written the proofs and so you could not have written the multiplication function.



